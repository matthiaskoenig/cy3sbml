package org.cy3sbml.miriam.registry;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.cy3sbml.miriam.registry.data.*;
import org.cy3sbml.util.IOUtil;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 * Fetch datatype info from the xml file generated by the identifiers.org registry.
 */
public class RegistryDatabase {
    
	/** The singleton instance of {@link RegistryDatabase}. */
	static private RegistryDatabase instance = null;

	/** The set of all {@link DataType}. */
	private Set<DataType> dataTypesSet = new TreeSet<>();

	/** {@link Map} between Datatype id, eg MIR:00000015 and {@link DataType} instances.*/
	private TreeMap<String, DataType> idDataTypeMap = new TreeMap<>();

	/** {@link Map} between Datatype name and {@link DataType} instances. */
	private TreeMap<String, DataType> nameDataTypeMap = new TreeMap<>();

	/** {@link Map} between Datatype urn and {@link DataType} instances. */
	private HashMap<String, DataType> urnMap = new HashMap<>();

    /** {@link Map} between Datatype namespace and {@link DataType} instances. */
	private HashMap<String, DataType> namespaceMap = new HashMap<>();

    /** {@link Map} between Datatype uri and {@link DataType} instances. */
	private HashMap<String, DataType> uriMap = new HashMap<>();

    /** {@link Map} between tag name and a {@link Set} of {@link DataType} instances. */
	private HashMap<String, Set<DataType>> tagNameDataTypeMap = new HashMap<String, Set<DataType>>();

    /** {@link Map} between tag name and tag definition. */
    private HashMap<String, String> tagNameDefinitionMap = new HashMap<String, String>();

    
	/**
	 * Returns a singleton instance of {@link RegistryDatabase}.
	 * 
	 * <p>If the database is not initialized, it will try to load the data from
	 * a file. First looking for the system property 'registry.xml.export', if this property
	 * does not exist, it try to find a file named 'miriam.xml' on the local folder.
	 * 
	 * @return a singleton instance of {@link RegistryDatabase}.
	 */
	public static RegistryDatabase getInstance() {
	  if (instance == null) {
	    instance = defaultLoad();
	  }
	  return instance;
	}
	
	/**
	 * Returns an instance of {@link RegistryDatabase} loaded from the given {@link File}.
	 * 
	 * <p>If the database was not empty before, it will be emptied before loading the file.
	 * So this method can be used to update the database when the export file has been changed. 
	 * 
	 * @param file the file that contain the export from the identifiers.org registry database.
	 * @return an  instance of {@link RegistryDatabase} loaded from the given {@link File}.
	 * @throws FileNotFoundException if the File does not exist
	 */
	public static RegistryDatabase loadFromFile(File file) throws FileNotFoundException {
	  if (instance != null) {
	    instance.clear();
	  }
	  instance = read(new FileInputStream(file));
	  return instance;
	}
	
	/**
	 * Returns an instance of {@link RegistryDatabase} loaded from the given {@link InputStream}.
     * 
     * <p>If the database was not empty before, it will be emptied before loading from the stream.
     * So this method can be used to update the database when the export file has been changed. 

	 * @param inputStream  the inputStream that contain the export from the identifiers.org registry database.
	 * @return an instance of {@link RegistryDatabase} loaded from the given {@link InputStream}.
	 */
	public static RegistryDatabase loadFromInputStream(InputStream inputStream) {
      if (instance != null) {
        instance.clear();
      }
      instance = read(inputStream);
	  return instance;
    }
	
	/** Clears the Registry database. */
	private void clear() {
	  dataTypesSet = new TreeSet<>();
	  idDataTypeMap = new TreeMap<>();
	  nameDataTypeMap = new TreeMap<>();
	  urnMap = new HashMap<>();
	  namespaceMap = new HashMap<>();
	  uriMap = new HashMap<>();
	  tagNameDataTypeMap = new HashMap<>();
	  tagNameDefinitionMap = new HashMap<>();
	}

	/////////////////////////////////////////////////
    // DATA ACCESS
    /////////////////////////////////////////////////

	/** Returns a {@link DataType} from the given id, eg MIR:00000015. */
	public DataType getDatatypeById(String datatypeId) {
		return idDataTypeMap.get(datatypeId);
	}

	/** Returns a {@link DataType} from the given uri, eg http://identifiers.org/pubmed/. */
	public DataType getDataTypeByURI(String uri) {
		return uriMap.get(uri);
	}

	/** Returns a {@link DataType} from the given name (or synonym), eg Enzyme Nomenclature or EC code. */
	public DataType getDataTypeByName(String name) {
		return nameDataTypeMap.get(name);
	}

	/** Returns the whole {@link DataType} set. */
	public Collection<DataType> getDataTypes() {
		return idDataTypeMap.values();
	}

	/** Returns the {@link DataType} URN for the given datatype id. */
	public String getURNByDatatypeId(String datatypeId) {
		return getDatatypeById(datatypeId).getURN();
	}

	/** Returns the {@link DataType} URL for the given datatype id. */
	public String getURLByDatatypeId(String datatypeId) {
		return getDatatypeById(datatypeId).getURL();
	}

	/** Returns the {@link DataType} URN for the given datatype name or synonym. */
	public String getURNByDataTypeName(String name) {
		return getDataTypeByName(name).getURN();
	}

	/** Returns the {@link DataType} URL for the given datatype name or synonym. */
	public String getURLByDataTypeName(String name) {
		return getDataTypeByName(name).getURL();
	}

	/** Returns the {@link DataType} associated with the given uri. */
	public DataType getDatatypeByURI(String uri) { return uriMap.get(uri); }

	/** Returns the {@link Map} of uris and {@link DataType}. */
	public Map<String, DataType> getURIMap() { return uriMap; }
	
	/** Returns the {@link Map} of names and synonyms and {@link DataType}. */
	public Map<String, DataType> getNameMap() 
	{
		return nameDataTypeMap;
	}

	/** Returns the {@link Map} of datatype id and {@link DataType}. */
	public Map<String, DataType> getDataTypeMap() 
	{
		return idDataTypeMap;
	}

	/** Returns the {@link Set} of {@link DataType} associated with the given tag name. */
	public Set<DataType> getDataTypesByTagName(String tagName) { return tagNameDataTypeMap.get(tagName); }

    /** Returns the {@link Map} of tag names and tag definitions. */
    public Map<String, String> getTagNameDefinitionMap(String tagName) { return tagNameDefinitionMap; }


    /////////////////////////////////////////////////
    // DATA LOADING
    /////////////////////////////////////////////////
    /** Read the default file from resources. */
    private static RegistryDatabase defaultLoad() {
        InputStream miriamStream = IOUtil.readResource("/miriam/IdentifiersOrg-Registry.xml");
        return read(miriamStream);
    }

    /** The parser for the RegistryDatabase. */
    private static RegistryDatabase read(InputStream inputStream) {

        BufferedInputStream stream = new BufferedInputStream(inputStream);
        Document document = null;
        try {
            document = create(stream, false);
        } catch (RuntimeException e) {
            throw e;
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        instance = new RegistryDatabase();

        /// datatypes ///
        NodeList datatypes_list = document.getElementsByTagName("datatype");
        for (int i = 0; i < datatypes_list.getLength(); ++i) {
            Element datatypeElement = (Element) datatypes_list.item(i);
            DataType dataType = new DataType();

            // id & name
            dataType.setId(datatypeElement.getAttribute("id"));
            instance.dataTypesSet.add(dataType);
            dataType.setName(datatypeElement.getElementsByTagName("name").item(0).getTextContent().trim());

            // obsolete
            String obsolete = datatypeElement.getAttribute("obsolete");
            dataType.setObsolete(Boolean.parseBoolean(obsolete));

            // replacement
            if (dataType.isObsolete()) {
                String replacementString = datatypeElement.getAttribute("replacement");
                dataType.setReplacedBy(replacementString);
            }

            // restricted
            String restrictedString = datatypeElement.getAttribute("restricted");
            dataType.setRestricted(Boolean.parseBoolean(restrictedString));

            // pattern
            dataType.setRegexp(datatypeElement.getAttribute("pattern"));

            // comment
            NodeList commentLists = datatypeElement.getElementsByTagName("comment");
            if (commentLists.getLength() > 0) {
                Element commentElt = (Element) commentLists.item(0);
                String comment = commentElt.getTextContent().trim();
                dataType.setObsoleteComment(comment);
            }

            // definition
            NodeList definitionLists = datatypeElement.getElementsByTagName("definition");
            if (definitionLists.getLength() > 0) {
                Element definitionElt = (Element) definitionLists.item(0);
                String definition = definitionElt.getTextContent().trim();
                dataType.setDefinition(definition);
            }

            // synonyms
            NodeList synonymLists = datatypeElement.getElementsByTagName("synonyms");
            if (synonymLists.getLength() > 0) {
                NodeList synonymList = ((Element) synonymLists.item(0)).getElementsByTagName("synonym");
                ArrayList<String> synoArrayList = new ArrayList<String>();

                for (int j = 0; j < synonymList.getLength(); ++j) {
                    Element synonym = (Element) synonymList.item(j);
                    String synoString = synonym.getTextContent().trim();
                    instance.nameDataTypeMap.put(synoString, dataType);
                    synoArrayList.add(synoString);
                }

                dataType.setSynonyms(synoArrayList);
            }

            /// URIs ///
            NodeList uriLists = datatypeElement.getElementsByTagName("uris");

            if (uriLists.getLength() > 0) {
                NodeList uriList = ((Element) uriLists.item(0)).getElementsByTagName("uri");
                ArrayList<String> deprecatedURIs = new ArrayList<String>();

                for (int j = 0; j < uriList.getLength(); ++j) {
                    Element uri = (Element) uriList.item(j);

                    instance.uriMap.put(uri.getTextContent(), dataType);

                    String uriType = uri.getAttribute("type");
                    String uriIsDeprecated = uri.getAttribute("deprecated");
                    String uriStr = uri.getTextContent();

                    if (uriType.equals("URN") && (!uriIsDeprecated.equals("true"))) {
                        dataType.setURN(uriStr);
                    } else if (uriType.equals("URL") && (!uriIsDeprecated.equals("true"))) {
                        dataType.setURL(uriStr);
                    } else {
                        deprecatedURIs.add(uriStr);
                    }
                }

                if (deprecatedURIs.size() > 0) {
                    dataType.setDeprecatedURIs(deprecatedURIs);
                }
            }

            ///  namespace ///
            NodeList namespaceLists = datatypeElement.getElementsByTagName("namespace");
            if (namespaceLists.getLength() > 0) {
                Element namespaceElt = (Element) namespaceLists.item(0);
                String namespace = namespaceElt.getTextContent().trim();
                dataType.setNamespace(namespace);
            }

            instance.idDataTypeMap.put(dataType.getId(), dataType);
            instance.nameDataTypeMap.put(dataType.getName(), dataType);
            instance.urnMap.put(dataType.getURN(), dataType);
            instance.namespaceMap.put(dataType.getNamespace(), dataType);

            /// resources ///
            NodeList locationLists = datatypeElement.getElementsByTagName("resources");
            if (locationLists.getLength() > 0) {

                NodeList locationList = ((Element) locationLists.item(0)).getElementsByTagName("resource");

                for (int j = 0; j < locationList.getLength(); j++) {
                    Element location = (Element) locationList.item(j);

                    if (!location.getAttribute("obsolete").equalsIgnoreCase("true")) {

                        PhysicalLocation physicalLocation = new PhysicalLocation();

                        physicalLocation.setId(location.getAttribute("id"));
                        physicalLocation.setState(location.getAttribute("state"));
                        physicalLocation.setReliability(location.getAttribute("reliability"));
                        physicalLocation.setPreferred(Boolean.parseBoolean(location.getAttribute("preferred")));
                        physicalLocation.setPrimary(Boolean.parseBoolean(location.getAttribute("primary")));

                        physicalLocation.setUrlRoot(((Element) (location.getElementsByTagName("dataResource")
                                .item(0))).getTextContent());

                        String action = ((Element) (location
                                .getElementsByTagName("dataEntry")
                                .item(0))).getTextContent();

                        if (action.indexOf("$id") > -1) {
                            physicalLocation.setUrlPrefix(action.substring(0, action.indexOf("$id")));

                            physicalLocation.setUrlSuffix(action.substring(action.indexOf("$id") + 3, action.length()));
                        }

                        String info = ((Element) (location.getElementsByTagName("dataInfo").item(0))).getTextContent();
                        physicalLocation.setInfo(info);

                        NodeList dataEntityExampleNodes = location.getElementsByTagName("dataEntityExample");

                        if (dataEntityExampleNodes.getLength() > 0) {
                            String dataEntityExample = ((Element) (dataEntityExampleNodes.item(0))).getTextContent();
                            physicalLocation.setExample(dataEntityExample);
                        }

                        String institution = ((Element) (location.getElementsByTagName("dataInstitution").item(0))).getTextContent();

                        physicalLocation.setInstitution(institution);

                        String geographicalLocation = ((Element) (location.getElementsByTagName("dataLocation").item(0))).getTextContent();

                        physicalLocation.setLocation(geographicalLocation);

                        dataType.getResources().add(physicalLocation);
                    }
                }
            }

            /// documentations ///
            NodeList documentationLists = datatypeElement.getElementsByTagName("documentations");
            if (documentationLists.getLength() > 0) {

                NodeList documentationList = ((Element) documentationLists.item(0)).getElementsByTagName("documentation");

                for (int j = 0; j < documentationList.getLength(); j++) {
                    Element documentationElt = (Element) documentationList.item(j);

                    String type = documentationElt.getAttribute("type");
                    dataType.addDocumentationType(type);

                    String documentationUrl = documentationElt.getTextContent();
                    dataType.addDocumentationUrl(documentationUrl);
                }
            }

            /// restrictions ///
            NodeList restrictionLists = datatypeElement.getElementsByTagName("restrictions");

            if (restrictionLists.getLength() > 0) {
                NodeList restrictionList = ((Element) restrictionLists.item(0)).getElementsByTagName("restriction");

                for (int j = 0; j < restrictionList.getLength(); j++) {
                    Element restrictionElt = (Element) restrictionList.item(j);
                    Restriction restriction = new Restriction();
                    RestrictionType restrictionType = new RestrictionType();

                    String typeStr = restrictionElt.getAttribute("type");
                    String description = restrictionElt.getAttribute("desc");

                    restrictionType.setDesc(description);
                    restrictionType.setId(Integer.valueOf(typeStr));
                    restrictionType.setCategory(description);

                    restriction.setType(restrictionType);

                    NodeList statementList = restrictionElt.getElementsByTagName("statement");
                    NodeList linkList = restrictionElt.getElementsByTagName("link");

                    // statement -> info
                    if (statementList.getLength() > 0) {
                        String statement = statementList.item(0).getTextContent().trim();
                        restriction.setInfo(statement);
                    }

                    // link
                    if (linkList.getLength() > 0) {
                        String link = linkList.item(0).getTextContent().trim();
                        restriction.setLink(link);
                        restriction.setLinkText(((Element) linkList.item(0)).getAttribute("desc"));
                    }

                    dataType.addRestriction(restriction);
                }
            }

            /// annotation ///
            NodeList annotationLists = datatypeElement.getElementsByTagName("annotation");
            if (annotationLists.getLength() > 0) {

                NodeList formatList = ((Element) annotationLists.item(0)).getElementsByTagName("format");

                for (int j = 0; j < formatList.getLength(); j++) {
                    Element formatElt = (Element) formatList.item(j);

                    String formatName = formatElt.getAttribute("name");
                    Annotation annotation = new Annotation(formatName);

                    NodeList elementList = ((Element) formatElt.getElementsByTagName("elements").item(0)).getElementsByTagName("element");
                    for (int k = 0; k < elementList.getLength(); k++) {
                        String elementName = elementList.item(k).getTextContent().trim();
                        annotation.addTag(new Tag(elementName, elementName, null));
                    }
                    dataType.getAnnotations().add(annotation);
                }

            }

            /// tags ///
            NodeList tagsLists = datatypeElement.getElementsByTagName("tags");
            if (tagsLists.getLength() > 0) {

                NodeList tagList = ((Element) tagsLists.item(0)).getElementsByTagName("tag");

                for (int j = 0; j < tagList.getLength(); j++) {
                    Element tagElt = (Element) tagList.item(j);

                    String tagName = tagElt.getTextContent();

                    dataType.getTags().add(tagName);

                    Set<DataType> datatypeSet = instance.tagNameDataTypeMap.get(tagName);

                    if (datatypeSet == null) {
                        datatypeSet = new TreeSet<DataType>();
                        instance.tagNameDataTypeMap.put(tagName, datatypeSet);
                    }
                    datatypeSet.add(dataType);
                }
            }
        }

        /// definitions ///
        NodeList tagsLists = document.getElementsByTagName("listOfTags");

        if (tagsLists.getLength() > 0) {
            NodeList tagDefinitions = ((Element) tagsLists.item(0)).getElementsByTagName("tagDefinition");

            if (tagDefinitions.getLength() > 0) {
                for (int j = 0; j < tagDefinitions.getLength(); j++) {
                    Element tagElt = (Element) tagDefinitions.item(j);

                    String tagName = tagElt.getElementsByTagName("name").item(0).getTextContent();
                    String tagDefinition = tagElt.getElementsByTagName("definition").item(0).getTextContent();

                    // add them to the tag map
                    instance.tagNameDefinitionMap.put(tagName, tagDefinition);
                }
            }
        }

        // System.out.println(RegistryDatabase.instance.getNameMap().keySet());
        return instance;
    }

	
    /**
    *
    * Creates an XML DOM document by parsing the content of the specified byte
    * stream as XML, using a <i>nonvalidating</i> parser.
    * 
    * @param byteStream The byte stream which content is parsed as XML to
    * create the XML DOM document.
    * @param namespaceAware A flag to indicate whether the parser should know
    * about namespaces or not.
    * @return The <code>org.w3c.dom.Document</code> instance representing
    * the XML DOM document created from the <code>byteStream</code>
    * XML content.
    * @throws NullPointerException If <code>byteStream</code> is
    * <code>null</code>.
    * @throws RuntimeException If any error occurs (parser configuration
    * errors, I/O errors, SAX parsing errors).
    *
    */
    private static Document create(InputStream byteStream,
                                   boolean namespaceAware) {

        if (byteStream == null) {
            throw new NullPointerException();
        }

        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(namespaceAware);

            factory.setValidating(false);

            try {
                factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
            } catch (AbstractMethodError e) {
                // do nothing
            } catch (ParserConfigurationException e) {
                // do nothing
            }

            DocumentBuilder builder = factory.newDocumentBuilder();
            return builder.parse(byteStream);
        } catch (ParserConfigurationException e) {
            throw new RuntimeException(e);
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (SAXException e) {
            throw new RuntimeException(e);
        }
    }

   ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Testing the registry access.
     *
     * Creates the RegistryDatabase from the resource file.
     */
    public static void main(String[] args) throws FileNotFoundException {
        // use default load from resources
        RegistryDatabase db = RegistryDatabase.getInstance();

        for (DataType dataType : db.getDataTypes()) {
            System.out.println(dataType);
            for (PhysicalLocation p : dataType.getPhysicalLocations()) {
                if (p.isPrimary()) {
                    System.out.println(p.getId() + " is primary");
                }
            }
        }

        System.out.println("Full size after default load = " + RegistryDatabase.getInstance().getDataTypes().size());
        System.out.println("Size of the list of tags = " + RegistryDatabase.getInstance().tagNameDefinitionMap.size());
        System.out.println("Nb datatype tag with neuroscience = " + RegistryDatabase.getInstance().getDataTypesByTagName("neuroscience").size());

    }

}
